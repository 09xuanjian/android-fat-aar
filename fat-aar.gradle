/**
 * This is free and unencumbered software released into the public domain.

 Anyone is free to copy, modify, publish, use, compile, sell, or
 distribute this software, either in source code form or as a compiled
 binary, for any purpose, commercial or non-commercial, and by any
 means.

 In jurisdictions that recognize copyright laws, the author or authors
 of this software dedicate any and all copyright interest in the
 software to the public domain. We make this dedication for the benefit
 of the public at large and to the detriment of our heirs and
 successors. We intend this dedication to be an overt act of
 relinquishment in perpetuity of all present and future rights to this
 software under copyright law.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.

 For more information, please refer to <http://unlicense.org/>
 */


import com.android.annotations.NonNull
import com.android.manifmerger.ManifestMerger2
import com.android.manifmerger.ManifestMerger2.Invoker
import com.android.manifmerger.ManifestMerger2.MergeType
import com.android.manifmerger.MergingReport
import com.android.manifmerger.PlaceholderEncoder
import com.android.manifmerger.XmlDocument
import com.android.utils.ILogger
import com.google.common.base.Charsets
import com.google.common.io.Files
import proguard.gradle.ProGuardTask

/**
 * Fat AAR Lib generator v 0.2
 * Target Gradle Version :: 2.2.0
 *
 * Latest version available at https://github.com/adwiv/android-fat-aar
 * Please report issues at https://github.com/adwiv/android-fat-aar/issues
 *
 * This code is in public domain.
 *
 * Use at your own risk and only if you understand what it does. You have been warned ! :-)
 */

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:manifest-merger:25.2.0'
        classpath 'net.sf.proguard:proguard-gradle:5.2.1'
    }
}

configurations {
    embedded
}

dependencies {
    compile configurations.embedded
}

ext.libraryPaths = new ArrayList<String>()
ext.embeddedAarDirs = new ArrayList<String>()
ext.build_dir = "build";

ext.exploded_aar_dir = "build/intermediates/exploded-aar";
ext.classs_release_dir = "build/intermediates/classes/release";
ext.bundle_release_dir = "build/intermediates/bundles/release";
ext.manifest_aaapt_dir = "build/intermediates/manifests/aapt/release";

ext.base_r2x_dir = "build/fat-aar/release/";
ext.pree_r2x_dir = "build/fat-aar/release/pre-r2x";
ext.post_r2x_dir = "build/fat-aar/release/post-r2x";

afterEvaluate {
    // the list of dependency must be reversed to use the right overlay order.
    def dependencies = new ArrayList(configurations.embedded.resolvedConfiguration.firstLevelModuleDependencies)
    dependencies.reverseEach {
        def aarPath = "${exploded_aar_dir}/${it.moduleGroup}/${it.moduleName}/${it.moduleVersion}"
        if (!embeddedAarDirs.contains(aarPath)) {
            embeddedAarDirs.add(aarPath)
        }
    }

    dependencies.each {
        collectDependencies(it)
    }

    libraryPaths.each {
        println "Compile Dependency: $it";
    }

    // Merge Assets
    generateReleaseAssets.dependsOn embedAssets

    // Embed Resources by overwriting the inputResourceSets
    packageReleaseResources.dependsOn embedLibraryResources

    // TODO:?? Merge Native libraries - based on issue/15 - Untested
    if (tasks.findByPath('transformNative_libsWithSyncJniLibsForRelease') != null) {
        embedJniLibs.mustRunAfter transformNative_libsWithSyncJniLibsForRelease
    } else {
        NEEDTOFIX
    }

    bundleRelease.dependsOn embedJniLibs

    // Merge Embedded Manifests
    embedManifests.mustRunAfter processReleaseManifest
    bundleRelease.dependsOn embedManifests

    // Merge proguard files
    embedLibraryResources.dependsOn embedProguard

    if (tasks.findByPath('compileReleaseJavaWithJavac') != null) {
        embedJavaJars.mustRunAfter compileReleaseJavaWithJavac
    } else {
        NEEDTOFIX
    }

    if (tasks.findByPath('proguardRelease') != null) {
        proguardRelease.dependsOn embedJavaJars
    } else if (tasks.findByPath('transformClassesAndResourcesWithProguardForRelease') != null) {
        transformClassesAndResourcesWithProguardForRelease.dependsOn embedJavaJars
    }

    bundleRelease.dependsOn embedJavaJars
}

public void collectDependencies(ResolvedDependency it) {
    it.moduleArtifacts.each {
        artifact ->
            if (artifact.type == 'aar') {
                def aarPath = "${exploded_aar_dir}/${it.moduleGroup}/${it.moduleName}/${it.moduleVersion}"
                if (!embeddedAarDirs.contains(aarPath) && !libraryPaths.contains(aarPath))
                    libraryPaths.add(aarPath)
            } else if (artifact.type == 'jar') {
                def artifactPath = artifact.file
                if (!libraryPaths.contains(artifactPath))
                    libraryPaths.add(artifactPath)
            } else {
                throw new Exception("Unhandled Artifact of type ${artifact.type}")
            }
    }

    it.children.each {
        child ->
            collectDependencies(child)
    }
}

task embedLibraryResources << {
    def oldInputResourceSet = packageReleaseResources.inputResourceSets
    packageReleaseResources.conventionMapping.map("inputResourceSets") {
        getMergedInputResourceSets(oldInputResourceSet)
    }
}

private List getMergedInputResourceSets(List inputResourceSet) {
    //We need to do this trickery here since the class declared here and that used by the runtime
    //are different and results in class cast error
    def ResourceSetClass = inputResourceSet.get(0).class

    List newInputResourceSet = new ArrayList(inputResourceSet)

    embeddedAarDirs.each { aarPath ->
        try {
            def resname = (aarPath.split(exploded_aar_dir)[1]).replace('/', ':');
            def rs = ResourceSetClass.newInstance([resname, true] as Object[])
            rs.addSource(file("$aarPath/res"))
            // println "ResourceSet is " + rs
            newInputResourceSet += rs
        } catch (Exception e) {
            e.printStackTrace();
            throw e;
        }
    }

    return newInputResourceSet
}

/**
 * Assets are simple files, so just adding them to source set seems to work.
 */
task embedAssets << {
    embeddedAarDirs.each { aarPath ->
        // Merge Assets
        android.sourceSets.main.assets.srcDirs += file("$aarPath/assets")
    }
}

/**
 * Merge proguard.txt files from all library modules
 * @author Marian Kl√ºhspies
 */
task embedProguard << {
    println "====== Embedding proguard.txt files in " + project
    def proguardRelease = file("$bundle_release_dir/proguard.txt")
    embeddedAarDirs.each { aarPath ->
        try {
            def proguardLibFile = file("$aarPath/proguard.txt")
            if (proguardLibFile.exists())
                proguardRelease.append(proguardLibFile.text)
        } catch (Exception e) {
            e.printStackTrace();
            throw e;
        }
    }
}


task copyJavaJars << {
    embeddedAarDirs.each { aarPath ->
        // Collect list of all jar files
        FileTree jars = fileTree(dir: "$aarPath/jars", include: ['*.jar'])
        jars += fileTree(dir: "$aarPath/jars/libs", include: ['*.jar']);
        jars += fileTree(dir: "$aarPath", include: ['*.jar']);
        jars += fileTree(dir: "$aarPath/libs", include: ['*.jar']);

        // println "Embedding jars : " + jars

        // Explode all jar files to classes so that they can be proguarded
        jars.visit {
            FileVisitDetails element ->
                copy {
                    from(zipTree(element.file))
                    into(pree_r2x_dir)
                }
        }
    }
}

task generateRJava(dependsOn: copyJavaJars) << {
    // Now generate the R.java file for each embedded dependency
    def libPackageName = new XmlParser().parse(android.sourceSets.main.manifest.srcFile).@package
    def mappingRText = "# Mapping file to convert R.class to X.class" << '\n' << '\n';
    embeddedAarDirs.each { aarPath ->

        def aarManifest = new XmlParser().parse(file("$aarPath/AndroidManifest.xml"));
        def aarPackageName = aarManifest.@package
        String packagePath = aarPackageName.replace('.', '/')

        // Generate the R.java file and map to current project's R.java
        // This will recreate the class file
        def rTxt = file("$aarPath/R.txt")
        def rMap = new ConfigObject()

        if (rTxt.exists()) {
            rTxt.eachLine {
                line ->
                    def (type, subclass, name, value) = line.tokenize(' ')
                    rMap[subclass].putAt(name, type)
            }
        }

        def sb = "package $aarPackageName;" << '\n' << '\n'
        sb << 'public final class R {\n'

        mappingRText << "${aarPackageName}.R -> ${aarPackageName}.X:\n"
        mappingRText << "    void <init>() -> <init>\n"

        rMap.each {
            subclass, values ->
                sb << "  public static final class $subclass {" << '\n'

                mappingRText << "${aarPackageName}.R\$$subclass -> ${aarPackageName}.X\$$subclass:\n";
                mappingRText << "    void <init>() -> <init>\n"
                mappingRText << "    void <clinit>() -> <clinit>\n"

                values.each {
                    name, type ->
                        sb << "    public static $type $name = ${libPackageName}.R.${subclass}.${name};" << '\n'
                        mappingRText << "    $type $name -> $name\n"
                }
                sb << "    }" << '\n'
        }

        sb << '}' << '\n'

        mkdir("$pree_r2x_dir/$packagePath")
        file("$pree_r2x_dir/$packagePath/R.java").write(sb.toString())
    }

    //Force proguard to change R to X
    file("$base_r2x_dir/mapping-r.txt").write(mappingRText.toString())
}

task generateRClass(type: JavaCompile, dependsOn: generateRJava) {
    source = fileTree(dir: pree_r2x_dir, include: '**/*.java')
    destinationDir = file(pree_r2x_dir)
    dependencyCacheDir = file("$base_r2x_dir/cache")
    targetCompatibility = 1.7
    sourceCompatibility = 1.7
    classpath = files(classs_release_dir)
}

task generateXClass(type: ProGuardTask, dependsOn: generateRClass) {
    delete(post_r2x_dir)
    println generateXClass

    injars pree_r2x_dir, filter: '!**/R.java'
    outjars post_r2x_dir
    libraryjars android.getBootClasspath()
    libraryjars libraryPaths
    dontshrink
    dontoptimize
    dontpreverify
    dontwarn '**.R'
    dontwarn '**.R$*'
    keep 'class !**.R {*;}'
    keep 'class !**.R$* {*;}'
    applymapping "$base_r2x_dir/mapping-r.txt"
    printmapping "$base_r2x_dir/mapping.txt"
    printconfiguration "$base_r2x_dir/config.txt"
}

/**
 * To embed the class files, we need to change the R.class to X.class, so we explode it in another
 * location, proguard it to modify R to X, and then finally copy it to build location
 */
task embedJavaJars(dependsOn: generateXClass) << {
    copy {
        from fileTree(dir: post_r2x_dir)
        into file(classs_release_dir)
    }
}

/**
 * For some reason, adding to the jniLibs source set does not work. So we simply copy all files.
 */
task embedJniLibs << {
    println "====== Embedding jni libs in " + project
    embeddedAarDirs.each { aarPath ->
        println "======= Copying JNI from $aarPath/jni"
        // Copy JNI Folders
        copy {
            from fileTree(dir: "$aarPath/jni")
            into file("$bundle_release_dir/jni")
        }
    }
}

task embedManifests << {
    ILogger mLogger = new MiLogger()
    List<File> libraryManifests = new ArrayList<>()

    embeddedAarDirs.each { aarPath ->
        if (!libraryManifests.contains(aarPath)) {
            libraryManifests.add(file("$aarPath/AndroidManifest.xml"))
            // println "==== Added $aarPath Manifest"
        }
    }

    File reportFile = file("${build_dir}/embedManifestReport.txt")

    File origManifest = file("$bundle_release_dir/AndroidManifest.xml")
    File copyManifest = file("$bundle_release_dir/AndroidManifest.orig.xml")
    File aaptManifest = file("$manifest_aaapt_dir/AndroidManifest.xml")

    copy {
        from origManifest.parentFile
        into copyManifest.parentFile
        include origManifest.name
        rename(origManifest.name, copyManifest.name)
    }

    try {
        Invoker manifestMergerInvoker = ManifestMerger2.newMerger(copyManifest, mLogger, MergeType.APPLICATION)

        manifestMergerInvoker.addLibraryManifests(libraryManifests.toArray(new File[libraryManifests.size()]))

        // manifestMergerInvoker.setPlaceHolderValues(placeHolders)
        manifestMergerInvoker.setMergeReportFile(reportFile);

        MergingReport mergingReport = manifestMergerInvoker.merge();

        mLogger.info("Merging result:" + mergingReport.getResult());
        MergingReport.Result result = mergingReport.getResult();
        switch (result) {
            case MergingReport.Result.WARNING:
                mergingReport.log(mLogger);
        // fall through since these are just warnings.
            case MergingReport.Result.SUCCESS:
                XmlDocument xmlDocument = mergingReport.getMergedXmlDocument(MergingReport.MergedManifestKind.MERGED);
                try {
                    String annotatedDocument = mergingReport.getActions().blame(xmlDocument);
                    mLogger.verbose(annotatedDocument);
                } catch (Exception e) {
                    mLogger.error(e, "cannot print resulting xml");
                }
                save(xmlDocument, origManifest);
                mLogger.info("Merged manifest saved to " + origManifest);
                if (aaptManifest.exists()) {
                    new PlaceholderEncoder().visit(xmlDocument);
                    save(xmlDocument, aaptManifest);
                    mLogger.info("Merged aapt safe manifest saved to " + aaptManifest);
                }
                break;
            case MergingReport.Result.ERROR:
                mergingReport.log(mLogger);
                throw new RuntimeException(mergingReport.getReportString());
            default:
                throw new RuntimeException("Unhandled result type : " + mergingReport.getResult());
        }
    } catch (RuntimeException e) {
        // TODO: unacceptable.
        e.printStackTrace()
        throw new RuntimeException(e);
    }
}

private void save(XmlDocument xmlDocument, File out) {
    try {
        Files.write(xmlDocument.prettyPrint(), out, Charsets.UTF_8);
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}

class MiLogger implements ILogger {

    @Override
    void error(
            @com.android.annotations.Nullable Throwable t,
            @com.android.annotations.Nullable String msgFormat, Object... args) {
        System.err.println(String.format("========== ERROR : " + msgFormat, args))
        if (t) t.printStackTrace(System.err)
    }

    @Override
    void warning(@NonNull String msgFormat, Object... args) {
        System.err.println(String.format("========== WARNING : " + msgFormat, args))
    }

    @Override
    void info(@NonNull String msgFormat, Object... args) {
        System.out.println(String.format("========== INFO : " + msgFormat, args))
    }

    @Override
    void verbose(@NonNull String msgFormat, Object... args) {
        // System.out.println(String.format("========== DEBUG : " + msgFormat, args))
    }
}
